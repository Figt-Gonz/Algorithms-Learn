### 链表

#### 链表合并

1. [合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)

   **迭代方式**。此外有递归方式，占用更多栈空间。

   - 使用**虚拟头结点**，头结点不放置元素值，下一个元素是真正的链表元素。

     这样可以将首元素的赋值操作和后面的循环操作合并，并且一旦没有了首元素赋值，也就不需要进行判空操作（由后续完成）大大简化了代码。

   - 可直接改变原链表结构，无需新建节点元素。

     刚开始的顾虑就在于，害怕改变了原有的链表结构后影响链表正常遍历，但事实上没有影响到遍历，因为改变 `next` 的时候虽然无法通过它得到原来的下一个元素，但还存在 `point` 指针指向下一个（改变 `next` 的同时，会将 `point` 指向下一个，而不会丢失后续链表），所以无需担心。

2. [合并 k 个有序链表](https://leetcode.cn/problems/merge-k-sorted-lists/)

   假设 k 个链表，共 N 个元素

   - **自己实现的方式**：每次读取 k 个链表首元素，得到最小元素，加入到新链表后。此算法时间复杂度为**`O(kN)`**

   - **labuladong 进阶方式**：使用优先队列 **`PriorityQueue`** 自带的小顶堆结构，来获取最小元素，每次加入这个最小元素到新链表后。此算法时间复杂度为 **`O(Nlogk)`**

   - 使用合并两个有序链表，依次合并。链表共合并 k^2^ / 2 次，每个链表平均长度 N / k ，所以时间复杂度为**`O(kN / 2)`**

   - **另外的进阶思路**：本质就是归并排序，两两合并，平均每个链表合并 logk 次，共合并 k * logk 次，每个链表平均长度 N / k 时间复杂度也是 **`O(Nlogk)`** **和归并排序使用到了同样的思想思路** 效率最高

     [leetcode 题解](https://leetcode.cn/problems/merge-k-sorted-lists/solutions/220518/4-chong-fang-fa-xiang-jie-bi-xu-miao-dong-by-sweet/)

#### 链表分解

1. [分隔链表](https://leetcode.cn/problems/partition-list/)
   - 同样使用**虚拟头结点**，统一了头元素和后续元素操作，并到循环中，简化代码
   - 构造完成两个区域，结尾元素`next`置`null`防止成环
   - 最后连接两个区域（左指针指向右侧首元素即可，无需判断右侧区域是否为空）

#### 单链表倒数第 N 个结点

1. [删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/)

   - 分解问题，先能找到倒数第 N 个结点，再进行删除
   - 虚拟头结点，统一第一个元素和后续元素的删除操作

   技巧的巧妙之处在于**一次遍历找到第 N 个结点**：

   第一个指针走 N 步，设置第二个指针指向头结点，两指针同步走直到第一个指针遍历完成，此时第二个指针指向第 K - N + 1 个结点的位置，也就是倒数第 N 个元素了。

#### 单链表的中点

1. [链表的中间结点](https://leetcode.cn/problems/middle-of-the-linked-list/description/)

   快慢指针，快指针走两步，慢指针走一步

   - `p.next.next`的方式
   - `count % 2 == 0`的方式

   第一种更简洁，但第一次不敢用

#### 链表是否成环

类似链表中点的快慢指针，如果两个指针可以相遇，就代表成环；如果`fast`遇到空指针则代表无环。

**进阶：寻找链表环起点**

类似于倒数第 N 个结点，使用到了巧妙的数学关系

同样的成环逻辑，同样的快慢指针。不同的是当确定有环，也就是`slow`和`fast`相遇后，将`slow`重新指向头结点，`fast`和`slow`同步前进，最后相遇的地方就是环的起点。

**分析原理：**

假设相遇时，`slow`走了 k 步，那么`fast`走了 2k 步。它们相遇了（此时它们一定都在环中），代表`fast`比`slow`多走了整数圈，也就是 k 步就是整数圈。

假设相遇点距离起点距离为 m，则头结点距离相遇点距离为 k - m；

而`fast`从相遇点开始走 k 步，有到达相遇点，那么少走 m 步，也就是走 k - m 步，同样也到达了环起点。

#### 链表交点

1. [相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/description/)
   - 首尾相连的思路，让两个链表总长度相同；让链表成环；
   - `while(pA != pB)`这种操作来做相等判定，免去了使用`if(pA == pB) return pA;`判定，简化了代码。
